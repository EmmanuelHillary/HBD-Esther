const Promise = require('bluebird');
const chalk = require('chalk');
const api = require('./api');
const _ = require('lodash');

const ROOT_URL = 'https://deploy.etranzactglobal.com';
//const ROOT_URL = 'http://localhost:8088';
const BUILD_URL = `${ROOT_URL}/build`;
const DEPLOY_URL = `${ROOT_URL}/deploy`;

const ENV = Object.freeze({
  PROD: 1,
  TEST: 2
});

const ENV_DOMAIN_LOOKUP = Object.freeze({
  1: 'api.xcelapp.com',
  2: 'sandbox.xcelapp.com',
});

const ENV_LOOKUP = Object.freeze({
  1: 'Prod',
  2: 'Test',
});

const DEFAULT_BRANCH = 'develop';

exports.ENV = ENV;
exports.ENV_LOOKUP = ENV_LOOKUP;
exports.DEFAULT_BRANCH = DEFAULT_BRANCH;

exports.Deploy = class Deploy {
  constructor(app_id) {
    this.app_id = app_id;

    // try {
    //   this.config = JSON.parse(fs.readFileSync(untildify('~/.etranzactglobal.json')).toString());
    // } catch (e) {
    //   console.log(chalk`{red ERROR}: Couldn't read configs from {green ~/.etranzactglobal.json}`);
    //   console.log(e);
    //   process.exit();
    // }

    //this.slack = new WebClient(this.config.slack_token);
  }

  async init(env_id) {
    this.env_id = env_id;
    this.to_prod = env_id === ENV.PROD;
    this.to_test = env_id === ENV.TEST;
    this.DEPLOY_ENV = ENV_LOOKUP[env_id];
    this.DEPLOY_DOMAIN = ENV_DOMAIN_LOOKUP[env_id];

    this.current_builds = await this.recent_builds();
    this.current_deployments = await this.recent_deployment();
    console.log(this.current_builds);
    this.last_build = this.current_builds[0];
    this.last_deploy = this.current_deployments[0];
    this.is_deploying = await this.is_deploying(this.current_deployments);
    this.can_deploy = this.last_deploy.build.build_no < this.last_build.build_no;
  }

  async recent_builds() {
    const builds = await api.get(BUILD_URL, { params: { app: this.app_id } });
    return builds.data.data;
  }

  async recent_deployment() {
    const deployments = await api.get(DEPLOY_URL, { params: { app: this.app_id, env: this.DEPLOY_ENV } });
    return deployments.data.data;
  }

  async is_deploying(deployments) {
    let in_progress = false;
    deployments.find((deploy) => {
        if (deploy.state === 'in_progress') {
          in_progress = true;
          return true;
        } else if (deploy.state === 'deployed') {
          return false;
        }
      });
      return in_progress;
  }

  async post_build_deploy(target_build) {
    const { _id } = target_build;
    await api.post(DEPLOY_URL, { id: _id, env: this.DEPLOY_ENV });
  }

  async deployable_builds(builds) {
    return Promise.map(builds, async (build) => {
      const { diff_log } = await this.build_commits(build);
      return {
        title: [
          diff_log,
          ``,
        ].join('\n'),
        value: build.build_no,
      }
    });
  }

  async build_commits(build) {
    const commits = build.commits;
    const diffs = [];
    const icon = chalk`{green +}`;
   
    commits.forEach((commit) => {
      diffs.push(chalk` ${icon} {cyan ${commit.author}}{grey : ${commit.message}}`);
      diffs.push(chalk`      {yellow ${commit.id}}`)
    });

    return {
      diff_log: diffs.join('\n'),
    }
  }

  async commit_diffs(target_build, destination_build) {
    const diffs = [];
    const icon = chalk`{green +}`;
    const commits = target_build.commits.filter((commit) => {
      for (let i = 0; i < destination_build.commits.length; i++) {
        if (destination_build.commits[i].id === commit.id) {
          return false;
        }
      }
      return true;
    });

    diffs.push(chalk`New commits ({yellow ${commits.length}})`);

    commits.forEach((commit) => {
      diffs.push(chalk`   ${icon} {cyan ${commit.author}}{grey : ${commit.message}}`);
      diffs.push(chalk`   {yellow ${commit.id}}`)
    });

    return {
      diff_log: diffs.join('\n'),
    }
  }
}