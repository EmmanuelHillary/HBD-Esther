#!/usr/bin/env node
const chalk = require('chalk');
const command_line_args = require('command-line-args');
const prompts = require('prompts');
const Promise = require('bluebird');
const Progress = require('cli-progress');
const api = require('../lib/api');
const templates = require('../lib/templates');

const { Deploy, ENV_LOOKUP } = require('../lib/deploy');

async function get_app_id(action) {
  // fetch available application
  const progress_bar = new Progress.SingleBar({
    format: 'Fetching apps | ' + '{bar}' + ' | {percentage}% || {value}/{total} Chunks',
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true
  }, Progress.Presets.shades_classic);
  progress_bar.start(100, 0);
  // TODO (amadosi odaibo 24/11/2021) - Figure out how to get the loading bar to update according to download.
  progress_bar.update(50);
  progress_bar.update(100);

  try {
    const apps = await api.get('/application');
    progress_bar.stop();
    const choices = apps.data.applications.map(app => ({ title: chalk`${app.name}`, value: app.name }));
    choices.push({ title: 'I can\'t see my app. ', value: -1 });
    return prompts([{
      name: 'app-id',
      type: 'select',
      message: chalk`Which {magenta application} do you want to ${action}?`,
      initial: 0,
      choices,
    }]);
  } catch (e) {
    const message = chalk`{red [ERROR]}: Error getting applications: ${e}`;
    console.log(message);
    process.exit(0);
  }
}

async function get_deploy_options(action) {
  const choices = Object.keys(ENV_LOOKUP).map(env => ({ title: chalk`{yellow ${ENV_LOOKUP[env]}}`, value: env }));
  return prompts([
    {
      name: 'env-id',
      type: 'select',
      message: chalk`Which {magenta environment} do you want to ${action}?`,
      initial: 0,
      choices,
    }
  ]);
}

async function get_deployable_build_options(d, deployable_builds) {
  const deployable_build_choices = await d.deployable_builds(deployable_builds);
  return prompts([
    {
      name: 'build-no',
      type: 'select',
      message: 'Select a build',
      initial: 0,
      choices: deployable_build_choices,
    }
  ]);
}

async function get_deploy_confirmation(d) {
  const message = chalk`Do you want to promote the selected internal build to {cyan ${d.DEPLOY_ENV}}?`;
  return prompts([
    {
      name: 'confirmation',
      type: 'confirm',
      message,
    }
  ]);
}

async function run() {
  // this is the starting point of the script
  const options = command_line_args([
    { name: 'app-id', type: String },
    { name: 'tag', type: String },
    { name: 'env-id', type: Number },
    { name: 'help', alias: 'h', type: Boolean },
    { name: 'version', alias: 'v', type: Boolean },
  ]);

  // only prompt for missing values not set by the CLI invocation
  prompts.override(options);

  let action = chalk`{green deploy} to`;
  if (options.rollback) {
    action = chalk`{red rollback}`;
  } else if (options.debug) {
    action = chalk`{cyan debug}`;
  } else if (options.list) {
    action = chalk`{cyan list}`;
  }

  const resp = await get_app_id(action);
  if (!resp['app-id']) {
    // protects from a quick exit without choosing an app-id
    process.exit();
  }

  if (resp['app-id'] === -1) {
    console.log(chalk`To add your {cyan app}, put out a message in the {magenta #infra} channel.`);
    process.exit();
  }

  const deploy_options = await get_deploy_options(action);
  if (!deploy_options['env-id']) {
    // protects from a quick exit without choosing an env-id
    process.exit();
  }
  const app_env = parseInt(deploy_options['env-id'], 10);
  const app_id = resp['app-id'];
  const d = new Deploy(app_id, app_env);
  await d.init(app_env);

  console.log(`\n${templates.app_status_table(d)}\n`);

  // if (d.is_deploying) {
  //   console.log(chalk`{red Warning}: A deployment is already in progress for {green ${d.app_id}} on {yellow ${d.DEPLOY_ENV}}.`);
  //   console.log(chalk`Please wait until the current deployment is complete before initiating a new deployment.`);
  //   process.exit();
  // }

  if (!d.can_deploy) {
    console.log(templates.bad_internal_alert(d));
    process.exit();
  }

  const deployable_builds = d.current_builds.filter((build) => build.build_no > d.last_deploy.build.build_no );
  const answer = await get_deployable_build_options(d, deployable_builds);
  const build_number = answer['build-no'];
  const target_build = d.current_builds.find((build) => build.build_no === build_number);
  
  console.log(templates.compare_builds(d, target_build, d.last_deploy.build));

  const { diff_log } = await d.commit_diffs(target_build, d.last_deploy.build);
  console.log(diff_log);
  console.log('\n');

  console.log(templates.deploy_prod(d, target_build));
  const confirmation = await get_deploy_confirmation(d);

  if (! confirmation.confirmation) {
    process.exit();
  }

  await d.post_build_deploy(target_build);
  console.log(chalk`\nYour {cyan deploy} request has been sent successfully to {blueBright dev-bot}.`);
  console.log(chalk`The {cyan deploy} result will show up on slack in the {magenta #dev-deploys} channel.`);
}

try {
  Promise.resolve(run())
  .catch((e) => {
    console.error('Error in promise', e);
  })
} catch (e) {
  console.error('Error', e);
}